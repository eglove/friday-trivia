# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

union AuthenticatedItem = User

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordFailure | UserAuthenticationWithPasswordSuccess

type KeystoneAdminMeta {
    enableSessionItem: Boolean!
    enableSignout: Boolean!
    list(key: String!): KeystoneAdminUIListMeta
    lists: [KeystoneAdminUIListMeta!]!
}

type KeystoneAdminUIFieldMeta {
    createView: KeystoneAdminUIFieldMetaCreateView!
    customViewsIndex: Int
    fieldMeta: JSON
    isOrderable: Boolean!
    itemView(id: ID!): KeystoneAdminUIFieldMetaItemView
    label: String!
    listView: KeystoneAdminUIFieldMetaListView!
    path: String!
    viewsIndex: Int!
}

type KeystoneAdminUIFieldMetaCreateView {
    fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

type KeystoneAdminUIFieldMetaItemView {
    fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode!
}

type KeystoneAdminUIFieldMetaListView {
    fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

type KeystoneAdminUIListMeta {
    description: String
    fields: [KeystoneAdminUIFieldMeta!]!
    hideCreate: Boolean!
    hideDelete: Boolean!
    initialColumns: [String!]!
    initialSort: KeystoneAdminUISort
    isHidden: Boolean!
    itemQueryName: String!
    key: String!
    label: String!
    labelField: String!
    listQueryName: String!
    pageSize: Int!
    path: String!
    plural: String!
    singular: String!
}

type KeystoneAdminUISort {
    direction: KeystoneAdminUISortDirection!
    field: String!
}

type KeystoneMeta {
    adminMeta: KeystoneAdminMeta!
}

type Mutation {
    authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult!
    createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
    " Create a single Option item. "
    createOption(data: OptionCreateInput): Option
    " Create multiple Option items. "
    createOptions(data: [OptionsCreateInput]): [Option]
    " Create a single Question item. "
    createQuestion(data: QuestionCreateInput): Question
    " Create multiple Question items. "
    createQuestions(data: [QuestionsCreateInput]): [Question]
    " Create a single Quiz item. "
    createQuiz(data: QuizCreateInput): Quiz
    " Create multiple Quiz items. "
    createQuizzes(data: [QuizzesCreateInput]): [Quiz]
    " Create a single Role item. "
    createRole(data: RoleCreateInput): Role
    " Create multiple Role items. "
    createRoles(data: [RolesCreateInput]): [Role]
    " Create a single User item. "
    createUser(data: UserCreateInput): User
    " Create multiple User items. "
    createUsers(data: [UsersCreateInput]): [User]
    " Delete a single Option item by ID. "
    deleteOption(id: ID!): Option
    " Delete multiple Option items by ID. "
    deleteOptions(ids: [ID!]): [Option]
    " Delete a single Question item by ID. "
    deleteQuestion(id: ID!): Question
    " Delete multiple Question items by ID. "
    deleteQuestions(ids: [ID!]): [Question]
    " Delete a single Quiz item by ID. "
    deleteQuiz(id: ID!): Quiz
    " Delete multiple Quiz items by ID. "
    deleteQuizzes(ids: [ID!]): [Quiz]
    " Delete a single Role item by ID. "
    deleteRole(id: ID!): Role
    " Delete multiple Role items by ID. "
    deleteRoles(ids: [ID!]): [Role]
    " Delete a single User item by ID. "
    deleteUser(id: ID!): User
    " Delete multiple User items by ID. "
    deleteUsers(ids: [ID!]): [User]
    endSession: Boolean!
    redeemUserPasswordResetToken(email: String!, password: String!, token: String!): RedeemUserPasswordResetTokenResult
    sendUserPasswordResetLink(email: String!): SendUserPasswordResetLinkResult
    " Update a single Option item by ID. "
    updateOption(data: OptionUpdateInput, id: ID!): Option
    " Update multiple Option items by ID. "
    updateOptions(data: [OptionsUpdateInput]): [Option]
    " Update a single Question item by ID. "
    updateQuestion(data: QuestionUpdateInput, id: ID!): Question
    " Update multiple Question items by ID. "
    updateQuestions(data: [QuestionsUpdateInput]): [Question]
    " Update a single Quiz item by ID. "
    updateQuiz(data: QuizUpdateInput, id: ID!): Quiz
    " Update multiple Quiz items by ID. "
    updateQuizzes(data: [QuizzesUpdateInput]): [Quiz]
    " Update a single Role item by ID. "
    updateRole(data: RoleUpdateInput, id: ID!): Role
    " Update multiple Role items by ID. "
    updateRoles(data: [RolesUpdateInput]): [Role]
    " Update a single User item by ID. "
    updateUser(data: UserUpdateInput, id: ID!): User
    " Update multiple User items by ID. "
    updateUsers(data: [UsersUpdateInput]): [User]
}

" A keystone list "
type Option {
    _usersVotedMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): _QueryMeta
    content: String
    id: ID!
    isCorrect: Boolean
    question: Question
    userCreated: User
    usersVoted(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): [User!]!
    votes: Int
}

type Query {
    " Search for the Option item with the matching ID. "
    Option(where: OptionWhereUniqueInput!): Option
    " Search for the Question item with the matching ID. "
    Question(where: QuestionWhereUniqueInput!): Question
    " Search for the Quiz item with the matching ID. "
    Quiz(where: QuizWhereUniqueInput!): Quiz
    " Search for the Role item with the matching ID. "
    Role(where: RoleWhereUniqueInput!): Role
    " Search for the User item with the matching ID. "
    User(where: UserWhereUniqueInput!): User
    " Retrieve the meta-data for the Option list. "
    _OptionsMeta: _ListMeta
    " Retrieve the meta-data for the Question list. "
    _QuestionsMeta: _ListMeta
    " Retrieve the meta-data for the Quiz list. "
    _QuizzesMeta: _ListMeta
    " Retrieve the meta-data for the Role list. "
    _RolesMeta: _ListMeta
    " Retrieve the meta-data for the User list. "
    _UsersMeta: _ListMeta
    " Perform a meta-query on all Option items which match the where clause. "
    _allOptionsMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): _QueryMeta
    " Perform a meta-query on all Question items which match the where clause. "
    _allQuestionsMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): _QueryMeta
    " Perform a meta-query on all Quiz items which match the where clause. "
    _allQuizzesMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuizzesBy!], where: QuizWhereInput): _QueryMeta
    " Perform a meta-query on all Role items which match the where clause. "
    _allRolesMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortRolesBy!], where: RoleWhereInput): _QueryMeta
    " Perform a meta-query on all User items which match the where clause. "
    _allUsersMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): _QueryMeta
    " Retrieve the meta-data for all lists. "
    _ksListsMeta(where: _ksListsMetaInput): [_ListMeta]
    " Search for all Option items which match the where clause. "
    allOptions(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): [Option]
    " Search for all Question items which match the where clause. "
    allQuestions(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): [Question]
    " Search for all Quiz items which match the where clause. "
    allQuizzes(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuizzesBy!], where: QuizWhereInput): [Quiz]
    " Search for all Role items which match the where clause. "
    allRoles(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortRolesBy!], where: RoleWhereInput): [Role]
    " Search for all User items which match the where clause. "
    allUsers(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): [User]
    authenticatedItem: AuthenticatedItem
    keystone: KeystoneMeta!
    validateUserPasswordResetToken(email: String!, token: String!): ValidateUserPasswordResetTokenResult
}

" A keystone list "
type Question {
    _optionMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): _QueryMeta
    _usersVotedMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): _QueryMeta
    content: String
    id: ID!
    numberOfOptions: Int
    option(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): [Option!]!
    quiz: Quiz
    userCreated: User
    usersVoted(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): [User!]!
    votes: Int
}

" A keystone list "
type Quiz {
    _questionMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): _QueryMeta
    _usersVotedMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): _QueryMeta
    id: ID!
    numberOfQuestions: Int
    question(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): [Question!]!
    subject: String
    userCreated: User
    usersVoted(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): [User!]!
    votes: Int
    week: String
}

type RedeemUserPasswordResetTokenResult {
    code: PasswordResetRedemptionErrorCode!
    message: String!
}

" A keystone list "
type Role {
    _assignedToMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): _QueryMeta
    assignedTo(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortUsersBy!], where: UserWhereInput): [User!]!
    canManageQuizzes: Boolean
    canManageRoles: Boolean
    canManageUsers: Boolean
    canSeeOtherUsers: Boolean
    id: ID!
    name: String
}

type SendUserPasswordResetLinkResult {
    code: PasswordResetRequestErrorCode!
    message: String!
}

" A keystone list "
type User {
    _optionsMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): _QueryMeta
    _questionsMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): _QueryMeta
    _quizzesMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuizzesBy!], where: QuizWhereInput): _QueryMeta
    _votedOnOptionsMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): _QueryMeta
    _votedOnQuestionsMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): _QueryMeta
    _votedOnQuizzesMeta(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuizzesBy!], where: QuizWhereInput): _QueryMeta
    currentWeekScore: Int
    email: String
    id: ID!
    name: String
    options(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): [Option!]!
    passwordResetIssuedAt: String
    passwordResetRedeemedAt: String
    passwordResetToken_is_set: Boolean
    password_is_set: Boolean
    questions(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): [Question!]!
    quizzes(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuizzesBy!], where: QuizWhereInput): [Quiz!]!
    role: Role
    totalScore: Int
    votedOnOptions(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortOptionsBy!], where: OptionWhereInput): [Option!]!
    votedOnQuestions(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuestionsBy!], where: QuestionWhereInput): [Question!]!
    votedOnQuizzes(first: Int, orderBy: String, search: String, skip: Int, sortBy: [SortQuizzesBy!], where: QuizWhereInput): [Quiz!]!
}

type UserAuthenticationWithPasswordFailure {
    code: PasswordAuthErrorCode!
    message: String!
}

type UserAuthenticationWithPasswordSuccess {
    item: User!
    sessionToken: String!
}

type ValidateUserPasswordResetTokenResult {
    code: PasswordResetRedemptionErrorCode!
    message: String!
}

type _ListAccess {
    """

    Access Control settings for the currently logged in (or anonymous)
    user when performing 'auth' operations.
    """
    auth: JSON
    """

    Access Control settings for the currently logged in (or anonymous)
    user when performing 'create' operations.
    NOTE: 'create' can only return a Boolean.
    It is not possible to specify a declarative Where clause for this
    operation
    """
    create: Boolean
    """

    Access Control settings for the currently logged in (or anonymous)
    user when performing 'delete' operations.
    """
    delete: JSON
    """

    Access Control settings for the currently logged in (or anonymous)
    user when performing 'read' operations.
    """
    read: JSON
    """

    Access Control settings for the currently logged in (or anonymous)
    user when performing 'update' operations.
    """
    update: JSON
}

type _ListInputTypes {
    "Create mutation input type name"
    createInput: String
    "Create many mutation input type name"
    createManyInput: String
    "Update mutation name input"
    updateInput: String
    "Update many mutation name input"
    updateManyInput: String
    "Input type for matching multiple items"
    whereInput: String
    "Input type for matching a unique item"
    whereUniqueInput: String
}

type _ListMeta {
    "Access control configuration for the currently authenticated request"
    access: _ListAccess
    "The list's user-facing description"
    description: String
    "The Keystone list key"
    key: String
    "The list's display name in the Admin UI"
    label: String
    "The Keystone List name"
    name: String @deprecated(reason : "Use `key` instead")
    "The list's data path"
    path: String
    "The list's plural display name"
    plural: String
    "Information on the generated GraphQL schema"
    schema: _ListSchema
    "The list's singular display name"
    singular: String
}

type _ListMutations {
    "Create mutation name"
    create: String
    "Create many mutation name"
    createMany: String
    "Delete mutation name"
    delete: String
    "Delete many mutation name"
    deleteMany: String
    "Update mutation name"
    update: String
    "Update many mutation name"
    updateMany: String
}

type _ListQueries {
    "Single-item query name"
    item: String
    "All-items query name"
    list: String
    "List metadata query name"
    meta: String
}

type _ListSchema {
    "Information about fields defined on this list"
    fields(where: _ListSchemaFieldsInput): [_ListSchemaFields]
    "Top-level GraphQL input types"
    inputTypes: _ListInputTypes
    "Top-level GraphQL mutation names"
    mutations: _ListMutations
    """

    Top level GraphQL query names which either return this type, or
    provide aggregate information about this type
    """
    queries: _ListQueries
    """

    Information about fields on other types which return this type, or
    provide aggregate information about this type
    """
    relatedFields: [_ListSchemaRelatedFields]
    "The typename as used in GraphQL queries"
    type: String
}

type _ListSchemaFields {
    "The name of the field in its list"
    name: String @deprecated(reason : "Use `path` instead")
    "The path of the field in its list"
    path: String
    "The field type (ie, Checkbox, Text, etc)"
    type: String
}

type _ListSchemaRelatedFields {
    "A list of GraphQL field names"
    fields: [String]
    "The typename as used in GraphQL queries"
    type: String
}

type _QueryMeta {
    count: Int
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
    edit
    hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
    edit
    hidden
    read
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
    hidden
    read
}

enum KeystoneAdminUISortDirection {
    ASC
    DESC
}

enum PasswordAuthErrorCode {
    FAILURE
    IDENTITY_NOT_FOUND
    MULTIPLE_IDENTITY_MATCHES
    SECRET_MISMATCH
    SECRET_NOT_SET
}

enum PasswordResetRedemptionErrorCode {
    FAILURE
    IDENTITY_NOT_FOUND
    MULTIPLE_IDENTITY_MATCHES
    TOKEN_EXPIRED
    TOKEN_MISMATCH
    TOKEN_NOT_SET
    TOKEN_REDEEMED
}

enum PasswordResetRequestErrorCode {
    IDENTITY_NOT_FOUND
    MULTIPLE_IDENTITY_MATCHES
}

enum SortOptionsBy {
    content_ASC
    content_DESC
    id_ASC
    id_DESC
    isCorrect_ASC
    isCorrect_DESC
    question_ASC
    question_DESC
    userCreated_ASC
    userCreated_DESC
    usersVoted_ASC
    usersVoted_DESC
    votes_ASC
    votes_DESC
}

enum SortQuestionsBy {
    content_ASC
    content_DESC
    id_ASC
    id_DESC
    numberOfOptions_ASC
    numberOfOptions_DESC
    option_ASC
    option_DESC
    quiz_ASC
    quiz_DESC
    userCreated_ASC
    userCreated_DESC
    usersVoted_ASC
    usersVoted_DESC
    votes_ASC
    votes_DESC
}

enum SortQuizzesBy {
    id_ASC
    id_DESC
    numberOfQuestions_ASC
    numberOfQuestions_DESC
    question_ASC
    question_DESC
    subject_ASC
    subject_DESC
    userCreated_ASC
    userCreated_DESC
    usersVoted_ASC
    usersVoted_DESC
    votes_ASC
    votes_DESC
    week_ASC
    week_DESC
}

enum SortRolesBy {
    assignedTo_ASC
    assignedTo_DESC
    canManageQuizzes_ASC
    canManageQuizzes_DESC
    canManageRoles_ASC
    canManageRoles_DESC
    canManageUsers_ASC
    canManageUsers_DESC
    canSeeOtherUsers_ASC
    canSeeOtherUsers_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
}

enum SortUsersBy {
    currentWeekScore_ASC
    currentWeekScore_DESC
    email_ASC
    email_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    options_ASC
    options_DESC
    passwordResetIssuedAt_ASC
    passwordResetIssuedAt_DESC
    passwordResetRedeemedAt_ASC
    passwordResetRedeemedAt_DESC
    questions_ASC
    questions_DESC
    quizzes_ASC
    quizzes_DESC
    role_ASC
    role_DESC
    totalScore_ASC
    totalScore_DESC
    votedOnOptions_ASC
    votedOnOptions_DESC
    votedOnQuestions_ASC
    votedOnQuestions_DESC
    votedOnQuizzes_ASC
    votedOnQuizzes_DESC
}

input CreateInitialUserInput {
    email: String
    name: String
    password: String
}

input OptionCreateInput {
    content: String
    isCorrect: Boolean
    question: QuestionRelateToOneInput
    userCreated: UserRelateToOneInput
    usersVoted: UserRelateToManyInput
    votes: Int
}

input OptionRelateToManyInput {
    connect: [OptionWhereUniqueInput]
    create: [OptionCreateInput]
    disconnect: [OptionWhereUniqueInput]
    disconnectAll: Boolean
}

input OptionUpdateInput {
    content: String
    isCorrect: Boolean
    question: QuestionRelateToOneInput
    userCreated: UserRelateToOneInput
    usersVoted: UserRelateToManyInput
    votes: Int
}

input OptionWhereInput {
    AND: [OptionWhereInput]
    OR: [OptionWhereInput]
    content: String
    content_contains: String
    content_contains_i: String
    content_ends_with: String
    content_ends_with_i: String
    content_i: String
    content_in: [String]
    content_not: String
    content_not_contains: String
    content_not_contains_i: String
    content_not_ends_with: String
    content_not_ends_with_i: String
    content_not_i: String
    content_not_in: [String]
    content_not_starts_with: String
    content_not_starts_with_i: String
    content_starts_with: String
    content_starts_with_i: String
    id: ID
    id_in: [ID]
    id_not: ID
    id_not_in: [ID]
    isCorrect: Boolean
    isCorrect_not: Boolean
    question: QuestionWhereInput
    question_is_null: Boolean
    userCreated: UserWhereInput
    userCreated_is_null: Boolean
    " condition must be true for all nodes "
    usersVoted_every: UserWhereInput
    " condition must be false for all nodes "
    usersVoted_none: UserWhereInput
    " condition must be true for at least 1 node "
    usersVoted_some: UserWhereInput
    votes: Int
    votes_gt: Int
    votes_gte: Int
    votes_in: [Int]
    votes_lt: Int
    votes_lte: Int
    votes_not: Int
    votes_not_in: [Int]
}

input OptionWhereUniqueInput {
    id: ID!
}

input OptionsCreateInput {
    data: OptionCreateInput
}

input OptionsUpdateInput {
    data: OptionUpdateInput
    id: ID!
}

input QuestionCreateInput {
    content: String
    numberOfOptions: Int
    option: OptionRelateToManyInput
    quiz: QuizRelateToOneInput
    userCreated: UserRelateToOneInput
    usersVoted: UserRelateToManyInput
    votes: Int
}

input QuestionRelateToManyInput {
    connect: [QuestionWhereUniqueInput]
    create: [QuestionCreateInput]
    disconnect: [QuestionWhereUniqueInput]
    disconnectAll: Boolean
}

input QuestionRelateToOneInput {
    connect: QuestionWhereUniqueInput
    create: QuestionCreateInput
    disconnect: QuestionWhereUniqueInput
    disconnectAll: Boolean
}

input QuestionUpdateInput {
    content: String
    numberOfOptions: Int
    option: OptionRelateToManyInput
    quiz: QuizRelateToOneInput
    userCreated: UserRelateToOneInput
    usersVoted: UserRelateToManyInput
    votes: Int
}

input QuestionWhereInput {
    AND: [QuestionWhereInput]
    OR: [QuestionWhereInput]
    content: String
    content_contains: String
    content_contains_i: String
    content_ends_with: String
    content_ends_with_i: String
    content_i: String
    content_in: [String]
    content_not: String
    content_not_contains: String
    content_not_contains_i: String
    content_not_ends_with: String
    content_not_ends_with_i: String
    content_not_i: String
    content_not_in: [String]
    content_not_starts_with: String
    content_not_starts_with_i: String
    content_starts_with: String
    content_starts_with_i: String
    id: ID
    id_in: [ID]
    id_not: ID
    id_not_in: [ID]
    numberOfOptions: Int
    numberOfOptions_gt: Int
    numberOfOptions_gte: Int
    numberOfOptions_in: [Int]
    numberOfOptions_lt: Int
    numberOfOptions_lte: Int
    numberOfOptions_not: Int
    numberOfOptions_not_in: [Int]
    " condition must be true for all nodes "
    option_every: OptionWhereInput
    " condition must be false for all nodes "
    option_none: OptionWhereInput
    " condition must be true for at least 1 node "
    option_some: OptionWhereInput
    quiz: QuizWhereInput
    quiz_is_null: Boolean
    userCreated: UserWhereInput
    userCreated_is_null: Boolean
    " condition must be true for all nodes "
    usersVoted_every: UserWhereInput
    " condition must be false for all nodes "
    usersVoted_none: UserWhereInput
    " condition must be true for at least 1 node "
    usersVoted_some: UserWhereInput
    votes: Int
    votes_gt: Int
    votes_gte: Int
    votes_in: [Int]
    votes_lt: Int
    votes_lte: Int
    votes_not: Int
    votes_not_in: [Int]
}

input QuestionWhereUniqueInput {
    id: ID!
}

input QuestionsCreateInput {
    data: QuestionCreateInput
}

input QuestionsUpdateInput {
    data: QuestionUpdateInput
    id: ID!
}

input QuizCreateInput {
    numberOfQuestions: Int
    question: QuestionRelateToManyInput
    subject: String
    userCreated: UserRelateToOneInput
    usersVoted: UserRelateToManyInput
    votes: Int
    week: String
}

input QuizRelateToManyInput {
    connect: [QuizWhereUniqueInput]
    create: [QuizCreateInput]
    disconnect: [QuizWhereUniqueInput]
    disconnectAll: Boolean
}

input QuizRelateToOneInput {
    connect: QuizWhereUniqueInput
    create: QuizCreateInput
    disconnect: QuizWhereUniqueInput
    disconnectAll: Boolean
}

input QuizUpdateInput {
    numberOfQuestions: Int
    question: QuestionRelateToManyInput
    subject: String
    userCreated: UserRelateToOneInput
    usersVoted: UserRelateToManyInput
    votes: Int
    week: String
}

input QuizWhereInput {
    AND: [QuizWhereInput]
    OR: [QuizWhereInput]
    id: ID
    id_in: [ID]
    id_not: ID
    id_not_in: [ID]
    numberOfQuestions: Int
    numberOfQuestions_gt: Int
    numberOfQuestions_gte: Int
    numberOfQuestions_in: [Int]
    numberOfQuestions_lt: Int
    numberOfQuestions_lte: Int
    numberOfQuestions_not: Int
    numberOfQuestions_not_in: [Int]
    " condition must be true for all nodes "
    question_every: QuestionWhereInput
    " condition must be false for all nodes "
    question_none: QuestionWhereInput
    " condition must be true for at least 1 node "
    question_some: QuestionWhereInput
    subject: String
    subject_contains: String
    subject_contains_i: String
    subject_ends_with: String
    subject_ends_with_i: String
    subject_i: String
    subject_in: [String]
    subject_not: String
    subject_not_contains: String
    subject_not_contains_i: String
    subject_not_ends_with: String
    subject_not_ends_with_i: String
    subject_not_i: String
    subject_not_in: [String]
    subject_not_starts_with: String
    subject_not_starts_with_i: String
    subject_starts_with: String
    subject_starts_with_i: String
    userCreated: UserWhereInput
    userCreated_is_null: Boolean
    " condition must be true for all nodes "
    usersVoted_every: UserWhereInput
    " condition must be false for all nodes "
    usersVoted_none: UserWhereInput
    " condition must be true for at least 1 node "
    usersVoted_some: UserWhereInput
    votes: Int
    votes_gt: Int
    votes_gte: Int
    votes_in: [Int]
    votes_lt: Int
    votes_lte: Int
    votes_not: Int
    votes_not_in: [Int]
    week: String
    week_gt: String
    week_gte: String
    week_in: [String]
    week_lt: String
    week_lte: String
    week_not: String
    week_not_in: [String]
}

input QuizWhereUniqueInput {
    id: ID!
}

input QuizzesCreateInput {
    data: QuizCreateInput
}

input QuizzesUpdateInput {
    data: QuizUpdateInput
    id: ID!
}

input RoleCreateInput {
    assignedTo: UserRelateToManyInput
    canManageQuizzes: Boolean
    canManageRoles: Boolean
    canManageUsers: Boolean
    canSeeOtherUsers: Boolean
    name: String
}

input RoleRelateToOneInput {
    connect: RoleWhereUniqueInput
    create: RoleCreateInput
    disconnect: RoleWhereUniqueInput
    disconnectAll: Boolean
}

input RoleUpdateInput {
    assignedTo: UserRelateToManyInput
    canManageQuizzes: Boolean
    canManageRoles: Boolean
    canManageUsers: Boolean
    canSeeOtherUsers: Boolean
    name: String
}

input RoleWhereInput {
    AND: [RoleWhereInput]
    OR: [RoleWhereInput]
    " condition must be true for all nodes "
    assignedTo_every: UserWhereInput
    " condition must be false for all nodes "
    assignedTo_none: UserWhereInput
    " condition must be true for at least 1 node "
    assignedTo_some: UserWhereInput
    canManageQuizzes: Boolean
    canManageQuizzes_not: Boolean
    canManageRoles: Boolean
    canManageRoles_not: Boolean
    canManageUsers: Boolean
    canManageUsers_not: Boolean
    canSeeOtherUsers: Boolean
    canSeeOtherUsers_not: Boolean
    id: ID
    id_in: [ID]
    id_not: ID
    id_not_in: [ID]
    name: String
    name_contains: String
    name_contains_i: String
    name_ends_with: String
    name_ends_with_i: String
    name_i: String
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_contains_i: String
    name_not_ends_with: String
    name_not_ends_with_i: String
    name_not_i: String
    name_not_in: [String]
    name_not_starts_with: String
    name_not_starts_with_i: String
    name_starts_with: String
    name_starts_with_i: String
}

input RoleWhereUniqueInput {
    id: ID!
}

input RolesCreateInput {
    data: RoleCreateInput
}

input RolesUpdateInput {
    data: RoleUpdateInput
    id: ID!
}

input UserCreateInput {
    currentWeekScore: Int
    email: String
    name: String
    options: OptionRelateToManyInput
    password: String
    passwordResetIssuedAt: String
    passwordResetRedeemedAt: String
    passwordResetToken: String
    questions: QuestionRelateToManyInput
    quizzes: QuizRelateToManyInput
    role: RoleRelateToOneInput
    totalScore: Int
    votedOnOptions: OptionRelateToManyInput
    votedOnQuestions: QuestionRelateToManyInput
    votedOnQuizzes: QuizRelateToManyInput
}

input UserRelateToManyInput {
    connect: [UserWhereUniqueInput]
    create: [UserCreateInput]
    disconnect: [UserWhereUniqueInput]
    disconnectAll: Boolean
}

input UserRelateToOneInput {
    connect: UserWhereUniqueInput
    create: UserCreateInput
    disconnect: UserWhereUniqueInput
    disconnectAll: Boolean
}

input UserUpdateInput {
    currentWeekScore: Int
    email: String
    name: String
    options: OptionRelateToManyInput
    password: String
    passwordResetIssuedAt: String
    passwordResetRedeemedAt: String
    passwordResetToken: String
    questions: QuestionRelateToManyInput
    quizzes: QuizRelateToManyInput
    role: RoleRelateToOneInput
    totalScore: Int
    votedOnOptions: OptionRelateToManyInput
    votedOnQuestions: QuestionRelateToManyInput
    votedOnQuizzes: QuizRelateToManyInput
}

input UserWhereInput {
    AND: [UserWhereInput]
    OR: [UserWhereInput]
    currentWeekScore: Int
    currentWeekScore_gt: Int
    currentWeekScore_gte: Int
    currentWeekScore_in: [Int]
    currentWeekScore_lt: Int
    currentWeekScore_lte: Int
    currentWeekScore_not: Int
    currentWeekScore_not_in: [Int]
    email: String
    email_contains: String
    email_contains_i: String
    email_ends_with: String
    email_ends_with_i: String
    email_i: String
    email_in: [String]
    email_not: String
    email_not_contains: String
    email_not_contains_i: String
    email_not_ends_with: String
    email_not_ends_with_i: String
    email_not_i: String
    email_not_in: [String]
    email_not_starts_with: String
    email_not_starts_with_i: String
    email_starts_with: String
    email_starts_with_i: String
    id: ID
    id_in: [ID]
    id_not: ID
    id_not_in: [ID]
    name: String
    name_contains: String
    name_contains_i: String
    name_ends_with: String
    name_ends_with_i: String
    name_i: String
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_contains_i: String
    name_not_ends_with: String
    name_not_ends_with_i: String
    name_not_i: String
    name_not_in: [String]
    name_not_starts_with: String
    name_not_starts_with_i: String
    name_starts_with: String
    name_starts_with_i: String
    " condition must be true for all nodes "
    options_every: OptionWhereInput
    " condition must be false for all nodes "
    options_none: OptionWhereInput
    " condition must be true for at least 1 node "
    options_some: OptionWhereInput
    passwordResetIssuedAt: String
    passwordResetIssuedAt_gt: String
    passwordResetIssuedAt_gte: String
    passwordResetIssuedAt_in: [String]
    passwordResetIssuedAt_lt: String
    passwordResetIssuedAt_lte: String
    passwordResetIssuedAt_not: String
    passwordResetIssuedAt_not_in: [String]
    passwordResetRedeemedAt: String
    passwordResetRedeemedAt_gt: String
    passwordResetRedeemedAt_gte: String
    passwordResetRedeemedAt_in: [String]
    passwordResetRedeemedAt_lt: String
    passwordResetRedeemedAt_lte: String
    passwordResetRedeemedAt_not: String
    passwordResetRedeemedAt_not_in: [String]
    passwordResetToken_is_set: Boolean
    password_is_set: Boolean
    " condition must be true for all nodes "
    questions_every: QuestionWhereInput
    " condition must be false for all nodes "
    questions_none: QuestionWhereInput
    " condition must be true for at least 1 node "
    questions_some: QuestionWhereInput
    " condition must be true for all nodes "
    quizzes_every: QuizWhereInput
    " condition must be false for all nodes "
    quizzes_none: QuizWhereInput
    " condition must be true for at least 1 node "
    quizzes_some: QuizWhereInput
    role: RoleWhereInput
    role_is_null: Boolean
    totalScore: Int
    totalScore_gt: Int
    totalScore_gte: Int
    totalScore_in: [Int]
    totalScore_lt: Int
    totalScore_lte: Int
    totalScore_not: Int
    totalScore_not_in: [Int]
    " condition must be true for all nodes "
    votedOnOptions_every: OptionWhereInput
    " condition must be false for all nodes "
    votedOnOptions_none: OptionWhereInput
    " condition must be true for at least 1 node "
    votedOnOptions_some: OptionWhereInput
    " condition must be true for all nodes "
    votedOnQuestions_every: QuestionWhereInput
    " condition must be false for all nodes "
    votedOnQuestions_none: QuestionWhereInput
    " condition must be true for at least 1 node "
    votedOnQuestions_some: QuestionWhereInput
    " condition must be true for all nodes "
    votedOnQuizzes_every: QuizWhereInput
    " condition must be false for all nodes "
    votedOnQuizzes_none: QuizWhereInput
    " condition must be true for at least 1 node "
    votedOnQuizzes_some: QuizWhereInput
}

input UserWhereUniqueInput {
    id: ID!
}

input UsersCreateInput {
    data: UserCreateInput
}

input UsersUpdateInput {
    data: UserUpdateInput
    id: ID!
}

input _ListSchemaFieldsInput {
    type: String
}

input _ksListsMetaInput {
    "Whether this is an auxiliary helper list"
    auxiliary: Boolean
    key: String
}


"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"The `Upload` scalar type represents a file upload."
scalar Upload
